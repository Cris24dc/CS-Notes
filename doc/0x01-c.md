# C Programming Language Cheat Sheet

<img src="../img/cLang/cLang.jpeg">

## üìå Basic Data Types

| Type            | Size    | Range                           | Description        |
| --------------- | ------- | ------------------------------- | ------------------ |
| `char`          | 1 byte  | -128 to 127                     | Single character   |
| `unsigned char` | 1 byte  | 0 to 255                        | Unsigned character |
| `short int`     | 2 bytes | -32,768 to 32,767               | Short integer      |
| `int`           | 4 bytes | -2,147,483,648 to 2,147,483,647 | Standard integer   |
| `long long int` | 8 bytes | Very large range                | Long integer       |
| `float`         | 4 bytes | \~6-7 decimal digits            | Single precision   |
| `double`        | 8 bytes | \~15-17 decimal digits          | Double precision   |

### üìè Size Check Example

```c
printf("%d\n", sizeof(int));
```

### üìö Limits with `<limits.h>`

To retrieve implementation-specific limits for integral types, include the `<limits.h>` header.

```c
#include <limits.h>
```

#### üîë Common Limits from `<limits.h>`

| Macro        | Description                       | Example Value             |
| ------------ | --------------------------------- | ------------------------- |
| `CHAR_BIT`   | Number of bits in a `char`        | 8                         |
| `CHAR_MIN`   | Minimum value of `char`           | -128                      |
| `CHAR_MAX`   | Maximum value of `char`           | 127                       |
| `INT_MIN`    | Minimum value of `int`            | -2,147,483,648            |
| `INT_MAX`    | Maximum value of `int`            | 2,147,483,647             |
| `UINT_MAX`   | Maximum value of `unsigned int`   | 4,294,967,295             |
| `LONG_MIN`   | Minimum value of `long`           | Typically ‚àí2,147,483,648  |
| `LONG_MAX`   | Maximum value of `long`           | Typically 2,147,483,647   |
| `ULONG_MAX`  | Max value of `unsigned long`      | 4,294,967,295 or higher   |
| `LLONG_MIN`  | Minimum value of `long long`      | Very large negative value |
| `LLONG_MAX`  | Maximum value of `long long`      | Very large positive value |
| `ULLONG_MAX` | Max value of `unsigned long long` | Max unsigned 64-bit value |

Use these constants to write portable, safe programs across different systems.

## üìÇ System Types: `<sys/types.h>`

The `<sys/types.h>` header defines data types used in system-level programming, especially for POSIX-compliant operating systems (like Linux). These types are typically used for file descriptors, process IDs, sizes, and more.

```c
#include <sys/types.h>
```

### üìå Common Types in `<sys/types.h>`

| Type        | Description                                             |
| ----------- | ------------------------------------------------------- |
| `pid_t`     | Process ID                                              |
| `uid_t`     | User ID                                                 |
| `gid_t`     | Group ID                                                |
| `off_t`     | File size or offset (used with `lseek`, `stat`, etc.)   |
| `mode_t`    | File permission/mode bits                               |
| `size_t`    | Unsigned size type (also from `<stddef.h>`)             |
| `ssize_t`   | Signed size type (used for return values, e.g., `read`) |
| `time_t`    | Time value (used with `time()`, `ctime()`, etc.)        |
| `dev_t`     | Device ID (used with `stat()`)                          |
| `ino_t`     | Inode number                                            |
| `nlink_t`   | Number of hard links                                    |
| `blksize_t` | Block size                                              |
| `blkcnt_t`  | Number of blocks                                        |

> These types improve portability and ensure consistency when interfacing with system calls or low-level I/O.

## üéØ Program Entry Point

### Basic Program Structure

```c
#include <stdio.h>

int main() {
    printf("Hello, World!\n");
    return 0;
}
```

### Full main() Function Signature

```c
int main(int argc, char** argv, char** envp)
```

- **argc** - argument count
- **argv** - argument values (array of strings)
- **envp** - environment variables (array of strings)

### Command Line Arguments Example

```c
#include <stdio.h>

int main(int argc, char** argv) {
    printf("Number of arguments: %d\n", argc);
    for (int i = 0; i < argc; i++) {
        printf("argv[%d]: %s\n", i, argv[i]);
    }
    return 0;
}
```

## üîó Pointers

### Declaration and Usage

```c
int *ptr;                    // Declare pointer
ptr = (int*)malloc(sizeof(int)); // Allocate memory
*ptr = 42;                   // Set value
printf("Value: %d\n", *ptr); // Access value
free(ptr);                   // Free memory
```

### Pointer Operators

| Operator | Description | Example     |
| -------- | ----------- | ----------- |
| `&`      | Address-of  | `&variable` |
| `*`      | Dereference | `*pointer`  |

## üì•üì§ Input/Output Functions

### Format Specifiers

| Specifier | Type         | Description            |
| --------- | ------------ | ---------------------- |
| `%d`      | int          | Decimal integer        |
| `%i`      | int          | Integer (detects base) |
| `%u`      | unsigned     | Unsigned decimal       |
| `%x`      | int          | Hexadecimal            |
| `%o`      | int          | Octal                  |
| `%c`      | char         | Single character       |
| `%s`      | char\*       | String                 |
| `%f`      | float/double | Floating point         |
| `%.2f`    | float/double | 2 decimal places       |
| `%02d`    | int          | Zero-padded integer    |

### Standard I/O

```c
// Reading input
int num;
char str[100];
scanf("%d", &num);           // Read integer
scanf("%s", str);            // Read string (no spaces)
gets(str);                   // Read line (deprecated - unsafe)

// Writing output
printf("Number: %d\n", num);
puts(str);                   // Print string with newline
```

### File I/O

```c
#include <stdio.h>

// Writing to file
FILE *file = fopen("output.txt", "w");
if (file != NULL) {
    fprintf(file, "Hello, file!\n");
    fclose(file);
}

// Reading from file
FILE *file = fopen("input.txt", "r");
if (file != NULL) {
    char buffer[100];
    if (fscanf(file, "%s", buffer) == 1) {
        printf("Read: %s\n", buffer);
    }
    fclose(file);
}
```

### File Modes

| Mode   | Description                 |
| ------ | --------------------------- |
| `"r"`  | Read only                   |
| `"w"`  | Write only (overwrites)     |
| `"a"`  | Append only                 |
| `"r+"` | Read and write              |
| `"w+"` | Read and write (overwrites) |

## üßæ `puts` vs `printf`, `gets` vs `scanf`, `f*` Functions

### üì§ Output

| Function    | Description                            |
| ----------- | -------------------------------------- |
| `puts()`    | Prints a string + newline              |
| `printf()`  | Prints formatted output                |
| `fputs()`   | Like `puts`, but to a stream (no `\n`) |
| `fprintf()` | Like `printf`, but to a stream         |

### üì• Input

| Function   | Description                          |
| ---------- | ------------------------------------ |
| `gets()`   | ‚ö†Ô∏è Unsafe. Reads line, no size check |
| `fgets()`  | ‚úÖ Safe. Reads line with size limit  |
| `scanf()`  | Reads formatted input                |
| `fscanf()` | Like `scanf`, but from a file/stream |

### üí° Note

- Functions with prefix `f` (e.g. `fputs`, `fprintf`, `fscanf`) allow **working with any stream**, not just standard input/output.
- Use `f*()` when reading/writing to files (`FILE *f = fopen(...)`).
- Prefer `fgets()` over `gets()` for safety.

## üñ•Ô∏è System Calls

### Common System Calls

```c
#include <fcntl.h>  // POSIX header file for open()
#include <unistd.h>

// File operations
int fd = open("file.txt", O_RDONLY);  // Open file
char buffer[100];
ssize_t bytes = read(fd, buffer, 99); // Read data
write(fd, "data", 4);                 // Write data
close(fd);                            // Close file

// Standard file descriptors
// STDIN_FILENO  (0) - Standard input
// STDOUT_FILENO (1) - Standard output
// STDERR_FILENO (2) - Standard error
```

### System Call vs Library Function

| System Call | Library Function        |
| ----------- | ----------------------- |
| `open()`    | `fopen()`               |
| `read()`    | `fread()`, `fscanf()`   |
| `write()`   | `fwrite()`, `fprintf()` |
| `close()`   | `fclose()`              |

> üìñ Full list of syscall numbers:
> [https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#x86-32_bit](https://chromium.googlesource.com/chromiumos/docs/+/master/constants/syscalls.md#x86-32_bit)

## üî§ String Manipulation in C

### üìö String Library (`<string.h>`)

To work with strings in C, you use functions provided by the standard **`<string.h>`** library:

```c
#include <string.h>

char str1[50] = "Hello";
char str2[] = "World";
char dest[100];
```

### üîß Common String Functions

| Function                   | Description                                                               |
| -------------------------- | ------------------------------------------------------------------------- |
| `strlen(s)`                | Returns the length of string `s` (excluding the null terminator).         |
| `strcpy(dest, src)`        | Copies the string `src` into `dest`.                                      |
| `strncpy(dest, src, n)`    | Copies up to `n` characters from `src` to `dest`.                         |
| `strcat(dest, src)`        | Appends string `src` to the end of `dest`.                                |
| `strncat(dest, src, n)`    | Appends up to `n` characters from `src` to `dest`.                        |
| `strcmp(s1, s2)`           | Compares `s1` and `s2` lexicographically.                                 |
| `strncmp(s1, s2, n)`       | Compares up to `n` characters of `s1` and `s2`.                           |
| `strchr(s, c)`             | Returns a pointer to the first occurrence of character `c` in string `s`. |
| `strrchr(s, c)`            | Returns a pointer to the last occurrence of character `c` in string `s`.  |
| `strstr(haystack, needle)` | Returns a pointer to the first occurrence of substring `needle`.          |
| `strtok(s, delim)`         | **Splits a string into tokens** using specified delimiters.               |

---

### üîç String Tokenization with `strtok`

The `strtok()` function is used to split a string into **tokens** (substrings), based on a set of delimiter characters.

#### ‚úÖ Example

```c
#include <stdio.h>
#include <string.h>

int main() {
    char text[] = "apple,banana,orange";
    char *token = strtok(text, ",");   // First call with the input string

    while (token != NULL) {
        printf("Token: %s\n", token);
        token = strtok(NULL, ",");     // Subsequent calls with NULL
    }

    return 0;
}
```

#### ‚öôÔ∏è How `strtok` Works

- **First call:** `strtok(original_string, delimiters)` ‚Äî returns the first token.
- **Subsequent calls:** `strtok(NULL, delimiters)` ‚Äî continues from where it left off.
- Replaces each delimiter with `\0` to separate the tokens.
- Modifies the original string (not safe for read-only strings).

#### ‚ö†Ô∏è Limitations

- **Not thread-safe**: It uses internal static state.
- Use `strtok_r()` in multithreaded environments (POSIX-compliant systems).

---

### üß™ String Comparison Results

| `strcmp()` Result | Meaning                      |
| ----------------- | ---------------------------- |
| `0`               | Strings are equal            |
| `< 0`             | First string < Second string |
| `> 0`             | First string > Second string |

## üî¢ Bitwise Operations

### Bitwise Operators

| Operator | Name        | Example  | Description             |
| -------- | ----------- | -------- | ----------------------- |
| `\|`     | OR          | `x \| y` | Bitwise OR              |
| `&`      | AND         | `x & y`  | Bitwise AND             |
| `^`      | XOR         | `x ^ y`  | Bitwise XOR             |
| `~`      | NOT         | `~x`     | Bitwise NOT             |
| `<<`     | Left Shift  | `x << n` | Shift left n positions  |
| `>>`     | Right Shift | `x >> n` | Shift right n positions |

### Truth Table

| x   | y   | x\|y | x&y | x^y |
| --- | --- | ---- | --- | --- |
| 0   | 0   | 0    | 0   | 0   |
| 0   | 1   | 1    | 0   | 1   |
| 1   | 0   | 1    | 0   | 1   |
| 1   | 1   | 1    | 1   | 0   |

### Shift Operations

```c
int x = 8;        // Binary: 1000
int left = x << 1;  // 16 (multiply by 2)
int right = x >> 1; // 4  (divide by 2)
```

## üîÑ Parameter Passing

### Pass by Value

```c
void modify_value(int x) {
    x = 100;  // Only changes local copy
}
```

### Pass by Reference (using pointers)

```c
void modify_reference(int *x) {
    *x = 100;  // Changes original value
}
```

### Arrays (implicitly passed by reference)

```c
void modify_array(int arr[], int size) {
    arr[0] = 999;  // Changes original array
}
```

## üîß GCC Compilation

```bash
# Basic compilation
gcc program.c -o program

# With debugging info
gcc -g program.c -o program

# With all warnings
gcc -Wall program.c -o program

# 32-bit compilation
gcc -m32 program.c -o program
```

## ‚ö†Ô∏è Common Pitfalls

### Memory Leaks

```c
// BAD: Memory leak
int *ptr = malloc(sizeof(int));
return 0;  // Memory never freed!

// GOOD: Proper cleanup
int *ptr = malloc(sizeof(int));
// ... use ptr ...
free(ptr);
return 0;
```

### Buffer Overflow

```c
// BAD: Potential overflow
char buffer[10];
gets(buffer);  // Unsafe!

// GOOD: Safe input
char buffer[10];
fgets(buffer, sizeof(buffer), stdin);
```

### Uninitialized Variables

```c
// BAD: Undefined behavior
int x;
printf("%d\n", x);  // x contains garbage

// GOOD: Initialize variables
int x = 0;
printf("%d\n", x);  // x is 0
```

## üìö Essential Headers

| Header     | Purpose           | Key Functions                      |
| ---------- | ----------------- | ---------------------------------- |
| `stdio.h`  | Standard I/O      | `printf()`, `scanf()`, `fopen()`   |
| `stdlib.h` | General utilities | `malloc()`, `free()`, `exit()`     |
| `string.h` | String operations | `strlen()`, `strcpy()`, `strcmp()` |
| `math.h`   | Math functions    | `sqrt()`, `pow()`, `sin()`         |
| `ctype.h`  | Character testing | `isdigit()`, `isalpha()`           |
| `time.h`   | Date and time     | `time()`, `clock()`                |
| `unistd.h` | UNIX standard     | `read()`, `write()`, `close()`     |
| `fcntl.h`  | File control      | `open()`, file flags               |

## üéØ Error Handling

```c
#include <errno.h>
#include <string.h>

FILE *file = fopen("nonexistent.txt", "r");
if (file == NULL) {
    fprintf(stderr, "Error: %s\n", strerror(errno));
    return 1;
}
```

## üî¢ Exit Codes

| Code  | Meaning                        |
| ----- | ------------------------------ |
| `0`   | Success                        |
| `1`   | General error                  |
| `2`   | Misuse of shell command        |
| `126` | Command invoked cannot execute |
| `127` | Command not found              |

### Using Exit Codes

```c
#include <stdlib.h>

int main() {
    if (/* error condition */) {
        exit(EXIT_FAILURE);  // or exit(1)
    }

    return EXIT_SUCCESS;     // or return 0
}
```
